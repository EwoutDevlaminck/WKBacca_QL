"""
Generator of a random field on a rectangular two-dimensional box.
"""

__author__ = 'Omar Maj (omar.maj@ipp.mpg.de)'
__copyright__ = ' '
__license__ = 'Max Planck Institut for Plasma Physics'
__version__ = '0.0.1'


# Import standard modules 
import math
import numpy as np

# Fluctuations constructed via the method of random phases
class Fluctuations_RandomPhases(object):
    
    """
    Objects of this class are generators of fluctuations constructed 
    by means of the method of random phases.
    
    Construction of the object:
    
    >>> deltaN = Fluctuations_RandomPhases(parameters)
    
    Here, 'parameters' is a dictionary containing the parameters of 
    the fluctuation model. For instance, one example of such a 
    dictionary can be defined by
    
    >>> import numpy as np
    >>> parameters = {
    ...   'x1': -1.,                        # lower bound in x
    ...   'x2': +1.,                        # upper bound in x
    ...   'z1': -0.5,                       # lower bound in z
    ...   'z2': +0.5,                       # upper bound in z
    ...   'Lperp': 0.1,                     # correlation length
    ...   'n0' : lambda x,z : -np.tanh(x),  # background
    ...   'dn_n0' : 0.8,                    # rms of fluctuations
    ...   'F' : lambda x,z : np.exp(-x**2), # fluctuation envelope
    ...   'tol' : 1.e-8,                    # tolerance 
    ... }

    The size of the dual box, and thus the number of harmonics 
    'Mx', 'Mz', are determined by the correlation length 'Lperp' 
    and the tolerance 'tol': 'Mx' and 'Mz' are set so that
    
        exp(-pi**2 * (Lperp/ax)**2 * Mx**2),  
        
    and
        
        exp(-pi**2 * (Lperp/az)**2 * Mz**2),
        
    are both smaller then 'tol'.
    
    The parameters 'F' and 'tol' are both optional. When not present 
    in the dictionary, the default definitions are
    
    >>> F = lambda x,z: ones_like(x) # Default for the envelope
    >>> tol = 1.e-4                  # Default for the tolerance
    
    REMARK: The functions 'n0' and 'F' must return array-like objects.
    
    The typical usage of the object, once constructed, is by direct 
    call which will generate a sample of the random fluctuations. As 
    arguments one needs to pass the grid point where the fluctuations 
    should be evaluated. For instance,
    
    >>> x = np.linspace(x1, x2, nptx) # nptx = number of points in x
    >>> z = np.linspace(z1, z2, nptz) # nptz = number of points in z
    >>> X, Z = np.meshgrid(x, z)      # two-dimensional mesh
    >>> sample1 = deltaN(X, Z)        # first sample of the field
    >>> sample2 = deltaN(X, Z)        # another sample of the field
    
    In the example above, 'deltaN' is the name of the object which is 
    called on the same grid (X, Z) twice, thus producing two 
    different samples. Since 'deltaN' represents a random field the 
    two samples might be quite different and correspond to two 
    statistically independent realization of the random field 
    (modeling turbulent density fluctuations). 
    
    The grid (X, Z) can also be generated by
    
    >>> X, Z = deltaN.grid(nptx, nptz) # the same grid as above
    
    Calling the object with argument X, Z is equivalent to the method,
    
    >>> sample3 = deltaN.sample(X, Z)
    
    Alternatively the method 'full' allows the user to build a full 
    sample of the field, that is, background plus fluctuations,
    
    >>> full_sample = deltaN.full(X, Z) # This includes the background.
    
    The methods 'sample' and 'full' as well as the direct call admit 
    the optional argument 'correlated', which must be a logical 
    variable (either True or False): 
    
    >>> sample4 = deltaN(X, Z)
    >>> sample5 = deltaN(X, Z, correlated=True) 
    
    The flag 'correlated' is used to generate correlated samples, i.e., 
    the array of random phases is not changed with the new call. For 
    instance, sample4 and sample5 are exactly the same, namely,
    
    >>> sample4 == sample5 # This should evaluate to True.
    
    The object 'deltaN' can also be called with passing one-dimensional 
    arrays, namely,
    
    >>> sample = deltaN(x,z)     # x and z are one-dimensional arrays
    
    Here, x = [x1, x2, x3, ..., xN] and z = [z1, z2, z3, ..., zN] 
    are one dimensional arrays and the return variable 
    sample = [sample1, sample2, ... sampleN] is an array with the 
    same shape such that sample1 is the value of the sample at 
    (x1, z1), sample2 is the value of the sample at (x2, z2), sample3 
    is the value of the sample at (x3, z3), ... and so on and so forth. 
    The values sample1, sample2, sample3 are not independent: they 
    follow the correlation built in the model.
    
    """
    
    # Constructor method
    def __init__(self, parameters):
        
        # Set basic parameters to attributes of the object
        self.x1 = parameters['x1']
        self.x2 = parameters['x2']
        self.z1 = parameters['z1']
        self.z2 = parameters['z2']
        self.Lperp = parameters['Lperp']
        self.n0 = parameters['n0']
        self.dn_n0 = parameters['dn_n0']
    
        # Set optional parameters to attributes
        try:
            self.F = parameters['F']
        except KeyError:
            self.F = lambda x,z: np.ones_like(x)
        try:
            self.tol = parameters['tol']
        except KeyError:
            self.tol = 1.e-4
        
        # Derive the size of the spatial box
        self.ax = self.x2 - self.x1
        self.az = self.z2 - self.z1
        
        # Compute some constants one and for all
        sigma_x = math.pi * self.Lperp / self.ax
        sigma_z = math.pi * self.Lperp / self.az
        sqrtlogtol = math.sqrt(abs(math.log(self.tol)))
        
        # Derive the size of the dual box and the number of harmonics
        # (setting exp(-pi**2 * (L/a)**2 * M**2) = tol is equivalent 
        #  to the condition
        #  (pi * L / a)**2 * M**2 = - log(tol) = |log(tol)| for tol<1., 
        #  from which we obtain M.)
        self.Mx = int(math.ceil(sqrtlogtol / sigma_x))
        self.Mz = int(math.ceil(sqrtlogtol / sigma_z))
        
        # Index set M of statistically independent Fourier harmonics 
        # excluding (0,0)
        # (this objects are python sets and "^" means union)
        Mset1 = {(k,0) 
                 for k in range(1, self.Mx+1)}
        Mset2 = {(0,l) 
                 for l in range(1, self.Mz+1)}
        Mset3 = {(k,l) 
                 for k in range(1, self.Mx+1) 
                 for l in range(1, self.Mz+1)}
        Mset4 = {(-k,l) 
                 for k in range(1, self.Mx+1) 
                 for l in range(1, self.Mz+1)}
        self.Mset = Mset1 ^ Mset2 ^ Mset3 ^ Mset4
        
        # Total number of independent harmonics (including 0,0)
        self.Nharm = 1 + len(self.Mset)
        
        # Estimate the maximum fluctuation
        MaxF = math.sqrt(2.)
        for kl in self.Mset:
            k, l = kl
            MaxF += 2. * math.exp(-(sigma_x * k)**2 - (sigma_z * l)**2 )
        MaxF *= self.dn_n0 * math.sqrt(2. * sigma_x * sigma_z / math.pi) 
        self.MaxRelativeFluctuation = MaxF
        
        # Build the amplitudes without the envelope, which is the same 
        # for all the harmonics and can be multiplied at the end
        #
        # ... initialization ...
        self.Phi = np.zeros([2*self.Mx+1, 2*self.Mz+1])
        #
        # ... reset to NaN for safety 
        # (if the wrong harmonic is picked up, you should notice) ...
        self.Phi[:,:] = np.NAN 
        #
        # ... (0,0) harmonic (note the different factor) ...
        self.Phi[0,0] = math.sqrt(4. * sigma_x * sigma_z / math.pi)
        #
        # ... loop over the set M of independent harmonics ...
        for kl in self.Mset:
            k, l = kl
            self.Phi[kl] = math.sqrt(2. * sigma_x * sigma_z / math.pi) \
                        * np.exp(-(sigma_x * k)**2 - (sigma_z * l)**2)
                
        # Initialize the array of random phases
        self.phases = np.random.random([self.Nharm])
        
        pass
    
    # Call method
    def __call__(self, x, z, correlated=False):
        
        return self.sample(x, z, correlated=correlated)
    
    # Generate a sample of the random field
    def sample(self, x, z, correlated=False):
        
        """
        Generate a sample of the field. This is equivalent to calling 
        the object (cf. doc string of the class). 
        """
        
        # Generate a new array of random phases, 
        # unless correlated sampling is used
        if not correlated:
            self.phases = np.random.random([self.Nharm])

        # Define the array of normalized coordinates
        xi = (x - self.x1) / self.ax
        zeta = (z - self.z1) / self.az

        # Evaluate the envelope function and the background on the grid
        envelope = self.dn_n0 * self.F(x, z)
        background = self.n0(x, z)
        
        # Initialize to the (0,0) harmonic 
        alpha = self.phases[0]
        deltaN = self.Phi[0,0] * np.cos(2. * np.pi * alpha) 
        
        # Build the sample by adding all independent harmonics
        ialpha = 1 # initialize index pointing to random phases
        for kl in self.Mset:
            k, l = kl
            alpha = self.phases[ialpha]
            deltaN += self.Phi[kl] * \
                    2. * np.cos(2.*np.pi * (k*xi + l*zeta + alpha))
            ialpha += 1 
            
        return background * envelope * deltaN
    
    # Utility function: generate a grid covering the whole spatial box
    def grid(self, nptx, nptz, indexing='xy'):
        
        """
        Generate a uniform 2d grid covering the whole domain specified 
        in the construction of the object with the desired number of 
        points in the x and z directions (arguments 'nptx' and 'nptz', 
        respectively). Example:
        
        >>> deltaN = Fluctuation_RandomPhases(parameters)
        >>> nptx = nptz = 100 # number of grid points in x and z
        >>> X, Z = deltaN.grid(nptx, nptz, indexing='xy')
        
        The return variables are 2D arrays as given by numpy.meshgrid.
        The string indexing is an opional argument with the same behavior 
        as in numpy.meshgrid.
        """
        
        x = np.linspace(self.x1, self.x2, nptx)
        z = np.linspace(self.z1, self.z2, nptz)
        
        return np.meshgrid(x, z, indexing=indexing) 
    
    # Full random field = background plus fluctuations
    def full(self, x, z, correlated=False):
        
        """
        Generate a sample of the full random field, i.e., background 
        plus fluctuations. This works like the 'sample' method, but 
        returns the full profile including the background. There is one 
        optional argument, namely the logical variable 'correlated', 
        which can be used for correlated sampling: When set to True, 
        samples are generated using a fixed array of random phases, so 
        that each call of the function produces exactly the same 
        realization of the random field. 
        The default value of 'correlated' is False.
        """
        
        # Sample the background
        background = self.n0(x, z)
        
        # Sample of fluctuations
        fluctuations = self.sample(x, z, correlated=correlated)
        
        # Build the full random field as a sum
        return background + fluctuations 
    
    # Estimator for the two-point correlation function
    def statistics(self, nsamples, x0, z0, x, z):
        
        """
        Generate a number 'nsamples' of samples and evaluate the 
        two-point correlation
        
          C(x0, y0, x, z) = E(deltaN(x0, z0) * deltaN(x,z)),
              
        where (x0, y0) is a fixed point with coordinates x0, z0 
        as float arguments, while (x, z) is a grid of points with 
        coordinates x, z passed as arrays. Within the same loop, the 
        average-value and the variance fields are also evaluated on the 
        same grid (x, z).
        """
        
        # Center point
        x0 = np.array([x0])
        z0 = np.array([z0])
        
        # Initialize an array of zeros for C
        C = np.zeros_like(x) # array for the correlation
        M = np.zeros_like(x) # array for the average
        V = np.zeros_like(x) # array for the variance
        
        # Build the estimator for the correlation
        for n in range(0, nsamples):
            # ... first generate a sample on (x0, z0) ...
            deltaN_x0z0 = self.sample(x0, z0)[0]
            # ... then a CORRELATED sample on the grid (x, z) ...    
            deltaN_xz = self.sample(x, z, correlated=True)
            # ... update the correlation array ...
            C += deltaN_x0z0 * deltaN_xz
            # ... update the mean field ...
            M += deltaN_xz
            # ... and update the variance ...
            V += deltaN_xz * deltaN_xz
            
        # Finalize the results
        correlation = C / nsamples
        mean_field = M / nsamples
        variance = V / nsamples - mean_field * mean_field
            
        return correlation, mean_field, variance
#
# End of the class


# Testing the sample generator
if __name__ == '__main__':

    # Populate the namespace with Pylab
    from pylab import *

    ################################
    # First test: uniform background
    ################################

    # Parameters
    x1 = -1.
    x2 = +1.
    z1 = -0.5
    z2 = +0.5
    Lperp = 0.2
    n0 = lambda x,z : np.ones_like(x)
    dn_n0 = 1.
    F = lambda x,z : np.ones_like(x)
    
    # Setting up the test case
    parameters = {
        'x1': x1,                
        'x2': x2,                
        'z1': z1,                
        'z2': z2,                
        'Lperp': Lperp,             
        'n0' : n0,
        'dn_n0': dn_n0,
        'F' : F,    
        'tol' : 1.e-10,         
    }

    # Construction of the object
    deltaN_simple = Fluctuations_RandomPhases(parameters)

    # Approximation of fluctuations upper bound
    approx_bound = dn_n0 * math.sqrt((2./math.pi)*(x2-x1)*(z2-z1)/Lperp**2)
    
    # Some data
    Mx = deltaN_simple.Mx
    Mz = deltaN_simple.Mz
    Nh = deltaN_simple.Nharm
    MaxF = deltaN_simple.MaxRelativeFluctuation
    print( 'Required max. sample frequency Mx in x = {}'.format(Mx) )
    print( 'Required max. sample frequency Mz in z = {}'.format(Mz) )
    print( 'Number of independent harmonics N = {}'.format(Nh) )
    print( 'Max. relative fluctuation = {}'.format(MaxF) )
    print( 'Estimated max. relative fluctuation = {}'.format(approx_bound) )

    # Define the sample grid
    nptx = 200
    nptz = 150
    X, Z = deltaN_simple.grid(nptx, nptz)

    # Generate and plot two samples
    sample1 = deltaN_simple(X, Z)
    sample2 = deltaN_simple(X, Z)

    # Maximum fluctuation
    max1 = np.max(np.abs(sample1))
    max2 = np.max(np.abs(sample2))
    print( 'Maximum fluctuation of sample1 = {}'.format(max1) )
    print( 'Maximum fluctuation of sample2 = {}'.format(max2) )

    # Plotting
    figure(1, figsize=(13,4))
    
    subplot(121, aspect='equal')
    pcolormesh(X, Z, sample1)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    colorbar()
    grid('on')
    
    subplot(122, aspect='equal')
    pcolormesh(X, Z, sample2)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    colorbar()
    grid('on')

    show()

    # Checking the correlation function (This will take a while ...)
    nsamples = 500 # (Reasonable convergence requires about 1000 samples)
    x0 = z0 = 0.
    C, M, V = deltaN_simple.statistics(nsamples, x0, z0, X, Z)

    # The theoretical value is a Gaussian centered in (0, 0)
    Vtheory = n0(X, Z)**2 * dn_n0 * F(X, Z)**2
    Ctheory = Vtheory * np.exp(-0.5 * (X**2 + Z**2) / Lperp**2)
    
    # Plotting
    figure(2, figsize=(13,20))

    subplot(321, aspect='equal')
    pcolormesh(X, Z, C)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    title('Correlation')
    colorbar()
    grid('on')

    subplot(322, aspect='equal')
    pcolormesh(X, Z, C - Ctheory)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    title('Absolute error on the correlation')
    colorbar()
    grid('on')

    subplot(323, aspect='equal')
    pcolormesh(X, Z, M)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    title('Mean')
    colorbar()
    grid('on')

    subplot(325, aspect='equal')
    pcolormesh(X, Z, V)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    title('Variance')
    colorbar()
    grid('on')

    subplot(326, aspect='equal')
    pcolormesh(X, Z, V - Vtheory)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    title('Absolute error on the variance')
    colorbar()
    grid('on')

    show()

    ################################
    # Second test: ASDEX-like
    ################################

    # Physics parameters
    x1 = 230.         # coordinate of the left boundary of the box in cm
    x2 = 250.         # coordinate of the right boundary of the box in cm
    z1 = -10.         # lower boundary of the box
    z2 = +10.         # upper boundary of the box
    Lpedestal = 2.    # scale length (in cm) of the pedestal
    Xpedestal = 245.  # coordinate of the center of the pedestal in cm
    Npedestal = 1.e13 # density at the pedestal top in cm^-3
    dn_n0 = 1.0       # relative level of fluctuations dn/n
    Lperp = 0.5       # correlation length in cm
    Xfluct = 246.     # position of the turbulence layer
    Wfluct = 2.       # width in cm of the turbulence layer
    
    # Background density and fluctuation envelope
    n0 = lambda x,z : 0.5 * Npedestal * \
         (1.-np.tanh((x-Xpedestal)/Lpedestal))
    F = lambda x, z : exp(- (x-Xfluct)**2 / Wfluct**2) 

    # Construction of the fluctuation object
    parameters ={'x1': x1, 
                 'x2': x2, 
                 'z1': z1, 
                 'z2': z2,
                 'Lperp': Lperp,
                 'n0' : n0,
                 'dn_n0': dn_n0,
                 'F' : F,
                 'tol' : 1.e-4}
    deltaN_AUG = Fluctuations_RandomPhases(parameters)
    
    # Generate the grid
    nptx = 200
    nptz = 201
    X, Z = deltaN_AUG.grid(nptx, nptz)
    
    # Sample the total field
    N = deltaN_AUG.full(X, Z)

    # Some data
    Mx = deltaN_simple.Mx
    Mz = deltaN_simple.Mz
    Nh = deltaN_simple.Nharm
    print( 'Required max. sample frequency Mx in x = {}'.format(Mx) )
    print( 'Required max. sample frequency Mz in z = {}'.format(Mz) )
    print( 'Number of independent harmonics N = {}'.format(Nh) )

    # plot of the full density (profile plus fluctuations) 
    figure(3, figsize=(8,8))

    subplot(111, aspect='equal')
    pcolormesh(X, Z, N)
    colorbar()
    contour(X, Z, X, [Xpedestal], colors='w', linewidths=3)
    xlabel('$x$', fontsize=20)
    ylabel('$z$', fontsize=20)
    title('total density')
    grid('on')

    # A section at z=constant of the full density
    figure(4, figsize=(10,6))

    index = int(nptz / 2)

    subplot(111)
    plot(X[index,:], N[index,:] * 1.e-13, label='total')
    plot(X[index,:], n0(X, Z)[index,:] * 1.e-13, label='unperturbed')
    legend()
    xlabel('$x$', fontsize=20)
    ylabel('$n$ [$10^{13} \mathrm{cm}^{-3}$]', fontsize=20)
    title('density profile at $z=$ {}'.format(Z[index,0]), fontsize=20)
    grid('on')

    # Check positivity of the total density
    Nmin = np.min(N)
    print( 'Minimum value of the total density = {} cm^-3'.format(Nmin) )

    show()

    # End testing
# End of file

